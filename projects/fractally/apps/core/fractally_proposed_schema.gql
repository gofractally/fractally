# TODO: Mutations
# Q: Pure media contributors (not attending meetings) can't earn rewards, right?
#   So they need a chain account but won't need any fractal membership or KYC, right?

#####################
# Abstract types
#####################
interface Node {
    id: ID!
}
interface PagingInfo {
    startCursor: String
    hasNextPage: Boolean!
    endCursor: String
    hasPreviousPage: Boolean!
}

#####################
# enums
#####################
enum TransferType {
    SEND
    RECEIVE
}
enum postsFilter {
    FOLLOWING
    RESPECTED
    RISING
    VOTABLE
    MYPOSTS
    PETITIONS
}
enum memberStatus {
    PENDING
    ACTIVE # good standing
    RESIGNED # ???
    EVICTED
    DEBTOR
    CLEARED # post eviction/judgement; Council has wiped the slate
}
enum councilMembershipHistoryEventType {
    ADDED
    REMOVED
}
enum PetitionStatus {
    PROPOSED
    APPROVED
    REJECTED
    EXECUTED
}
enum mediaContentType {
    POST
    PETITION
    COMMENT
}
#####################
# Base/Simple Types
#####################
# Q: Should all balances be AmountAsAsset? Or can we assume anything fractall-scoped will just hold a Float and assume the community's token?
type AmountAsAsset {
    tokenName: String!
    balance: Float!
}

#####################
# "Wallet", ie. Account Types
#####################
type Transfer implements AmountAsAsset {
    type: TransferType!
    otherParty: User!
    time: String!
    memo: String
}

type Swap {
    from: AmountAsAsset!
    to: AmountAsAsset!
    time: String!
}

union AccountEvent = Transfer | Swap

type AccountEventEdge {
    node: AccountEvent
    cursor: String
}
type AccountEventList {
    edges: [AccountEventEdge]
    totalCount: Int!
    pageInfo: PagingInfo
}

type ChainAccountDetails {
    balances: [AmountAsAsset]!
    pendingTransactions: AccountEventList
    AccountEventHistory: AccountEventList
}

type Query { # getAccount
    chainAccount(accountId: ID): ChainAccountDetails
}

#####################
# Fractal Membership Types
#####################
# TODO: Q: add means of querying for a "default" profile image/info, perhaps a default fractal to pull profile from
type Query { # getFractals
    fractals: fractalList
}
type FractalProfile {
    members: MemberList
    fundedMarketMakers: FractalList
    tokenSupply: AmountAsAsset
    tokensStaked: AmountAsAsset
    topPosts: PostList
    council: [Member]
    councilMembershipHistory: [councilMembershipHistoryEvent]
}

type Query { # getFractalProfile
    getFractalProfile(fractalId: ID!): FractalProfile
}
type Query { # getUnifiedMemberList and getFractalMemberList
    getUnifiedMemberList(chainAccountId: ID, filter: String): MemberList # optional filter = following, followers
    getFractalMemberList(
        chainAccountId: ID
        fractalId: ID
        filter: String
    ): MemberList # optional filter = following, followers
    searchUnifiedMemberList(chainAccountId: ID, search: String!): MemberList # search by member name, bio, or team name
    searchFractalMemberList(
        chainAccountId: ID
        fractalId: ID
        search: String!
    ): MemberList # search by member name, bio, or team name
}

# fractalMembershipRecord connects an account to a member
type fractalMembershipRecord {
    fractalName: Fractal
    member: Member
}
type Fractal implements Node {
    id: ID!
    name: String
    # Q: What Fractal Profile fields should we have? And can only the Founder, then the Council update them?
    # mission: String
    # website: String
    members: MemberList
    teams: TeamList
    tokenName: String
    # TODO: add pool totals here? stats that give summary of the community? Or is that only in the FractalProfile query?
}

type MembershipEvent {
    status: memberStatus
    timestamp: String
    memo: String # for evictions/judgements, clearing, resignation
}

type councilMembershipHistoryEvent {
    what: councilMembershipHistoryEventType
    who: Member
    date: String
}

#####################
# Account / Member Profile Types
#####################
# Q: Inviters can get recruitment rewards from Sponsorship, right?
#  So Inviters can get recruitment rewards from non-KYC sponsors, right?
# Q: Should non-members have fractal-independent profile info *as well*?
# Q: Should fractal membership history be exposed at the chain account level?
# Q: Media: anyone can pay to post, but does that mean any AccountHolder can post in any fractal? Or must we associate an account with a fractal for them to post? ie. is the author of a post always just an Account and never a Member type?

### QUERIES ###
type LoggedInUserDetails {
    account: AccountHolder
    chainAccount: ChainAccountDetails # can total balances for total in UI
}
type Query { # getLoggedInUser (first thing UI will call if user info cached)
    getLoggedInUserDetails(chainAccountId: ID): LoggedInUserDetails
}

type UnifiedMemberProfile {
    profile: Member
    posts: PostList # This is a personal feed, ie. posts from all member/followed fractals
    memberFractals: [Fractal]
    following: [Fractal]
}
type Query { # getUnifiedMemberProfile
    getUnifiedMemberProfile(chainAccountId: ID): UnifiedMemberProfile # option to grab other member's profile
}
type FractalMemberProfile {
    profile: Member
    posts: PostList # This is a fractal-scoped feed, ie. posts only from this fractal
    otherMemberFractals: [Fractal]
    following: [Fractal]
    team: Team
}
type Query { # getFractalMemberProfile
    getFractalMemberProfile(
        chainAccountId: ID
        fractalId: ID
    ): FractalMemberProfile # option to grab other member's profile
}

type AccountHolder { # for non-reward earnings, eg. sponsors as well as Æ’ractal Members
    account: Int
    # Q: Inviter (for recruitment purposes) will be per-fractal
    Inviter: AccountHolder # Q: Must be Member? Or could a non-member invite another non-member? No recruitment rewards in that case?
    following: [Fractal]!
    membership: [fractalMembershipRecord]! # isMember = membership.length > 0
    recoveryFractal: Fractal
}

# getMemberDetails
type Query {
    member(chainAccountId: ID!, fractalId: ID): Member
}

type MemberEdge {
    node: Member
    cursor: String
}
type MemberList {
    totalCount: Int!
    edges: [MemberEdge]
    pageInfo: PagingInfo
}

type MemberProfile {
    name: String # allow different names in different fractals
    # AccountHolder is currently cyclic until we resolve how we want to handle Accounts vs Membership
    account: AccountHolder # Q: allow different accounts in different fractals? Make this tie back to the chain account easy from the frontend?
    profilePicUrl: String
    bio: String
    socialLinks: String
}
type MemberRecentStats {
    avgRank: Float
    lastMeetingDate: String
    attendance: [Boolean]
    consensusHistory: [Boolean]
    respectEarnedTotal: Float
    respectEarnedAvg: Float
}
# Member is unaware of (which) fractal; a fractalMembershipRecord connects the Member with a particular fractal
type MemberStats {
    rank: Int # Current
    meetingArrivalTime: String # Last week's arrival time for claims someone was late
    # perhaps this should be eliminated because we have the entropy commit to mark their attendance (required to participate, right?)
    recentStats: MemberRecentStats
    balance: Float
    amountStaked: Float
}
type Member {
    profile: MemberProfile
    voteWeight: Float # Rank-based vote weight
    votePower: Float # percentage remaining
    team: Team
    inviter: Member # Inviter must be from same fractal
    status: memberStatus
    onCouncil: Boolean
    onVetoCouncil: Boolean
    membershipHistory: [MembershipEvent]
    stats: MemberStats # current and average member stats
}

#####################
# Post Types
#####################
type Query { # getPostDetails
    getPostDetails(postId: ID!): Post
}
type Query { # getAuthoredPosts
    getAuthoredPosts(authorChainAccountId: ID, fractalId: ID): PostList # Option to request authors other than loggedInUser and from a specific fractal
}

type PostEdge {
    node: Post
    cursor: String
}
type PostList {
    totalCount: Int!
    edges: [PostEdge]
    pageInfo: PageInfo
}
# getPosts
type Query {
    posts(fractalId: ID, filter: postsFilter, searchText: String): PostList
}

type MediaContentBasics {
    creationTime: String
    mediaContentType: mediaContentType
    author: AccountHolder
    title: String
    sourceFractal: Fractal
}
type PostPreview {
    basics: MediaContentBasics
    contentSummary: String
    PreviewImgUrl: String
}
type CommentEdge {
    node: Comment
    cursor: String
}
type CommentList {
    totalCount: Int!
    edges: [CommentEdge]
    pageInfo: PageInfo
}
type Comment implements Node {
    id: ID!
    parentNode: ID
    commenter: Member # must be member?
    basics: MediaContentBasics
}
type PostWeight {
    memberLikes: Int
    memberDislikes: Int
    likes: Int
    dislikes: Int
}
type Post implements Node {
    id: ID!
    basics: MediaContentBasics
    body: String
    mediaUrls: [String]
    amtEarned: Float
    postWeight: PostWeight # presents indicates vote-ability
    # petition-related fields
    proposer: Member
    proposed_time: String
    isImportant: Boolean
    comments: CommentList
}

#####################
# Petition Types
#####################
type PetitionVoteResult {
    approve: [Member] # Council members
    reject: [Member] # Council members
}
type PetitionDecision {
    post: Post
    petitionStatus: PetitionStatus
    executionTime: String
    trxid: String
    votes: PetitionVoteResult
}
type Query {
    getPetitionDecision(postId: ID): PetitionDecision
}

type PetitionEdge {
    node: Petition
    cursor: String
}
type PetitionList {
    totalCount: Int!
    edges: [PetitionEdge]
    pageInfo: PageInfo
}

#####################
# Team Types
#####################
type rewardHistoryItem implements Node {
    id: ID!
    meetingDate: String
    teamRank: Int
    rewards: Float
}
type RewardHistoryItemEdge {
    node: rewardHistoryItem
    cursor: String
}
type rewardHistoryList {
    totalCount: Int!
    edges: [rewardHistoryItemEdge]
    pageInfo: PageInfo
}
type TeamProfile {
    basics: Team
    posts(filter: String): PostList # filter = mostRespected, mostRecent
    petitionsActedOn: PetitionList
    rewardHistory: rewardHistoryList
}
type Query { # getTeam
    getTeam(teamId: ID): Team
    getTeamProfile(teamId: ID): TeamProfile
}

type TeamEdge {
    node: Team
    cursor: String
}
type TeamList {
    totalCount: Int!
    edges: [TeamEdge]
    pageInfo: PageInfo
}

type TeamStats {
    rank: Int
    rewardsPast20Weeks: Float
    avg20WeekRewards: Float
    numWeeksOnCouncil: Int
}
type Team implements Node {
    id: ID!
    name: String
    profilePicUrl: String
    bio: String
    websiteUrl: String
    socialLinks: String
    teamLead: Member
    members: [Member]
    onCouncil: Boolean
    stats: TeamStats
}

#####################
# Pool Types
#####################
type liquidityPoolStats {
    balance: AmountAsAsset
}
type MediaPoolStats {
    balance: AmountAsAsset
}
type SponsorPoolStats {
    balance: AmountAsAsset
    returnRate: Float
    avgDeposits: Float
}
type TeamPoolStats {
    balance: AmountAsAsset
}
type PoolStats {
    liquidityPool: LiquidityPoolStats
    mediaPool: MediaPoolStats
    sponsorPool: sponsorPoolStats
    teamPool: TeamPoolStats
}
type Query { # getPoolStats
    getPoolStats: PoolStats
}

#####################
# Weekly Meeting Types
#####################
type MeetingDetails {
    startTime: String
    members: [Member]
    memberMeetingStats: [MemberStats]
}
type Query { # getMeetingDetails
    getMeetingDetails(
        fractalId: ID
        meetingDate: String
        chainAccountId: ID
    ): MeetingDetails
}

#####################
# Misc Types
#####################
type NotificationEdge {
    node: String
    cursor: String
}
type NotificationList {
    totalCount: Int
    edges: [NotificationEdge]
    pageInfo: PagingInfo
}
type Notifications {
    important: [String] # petitions activity, app updates, etc.; Rich format to allow for links
    notifications: NotificationList # likes, replies, etc.
}
type Query { # getNotifications; this might need expansion depending on how we represent the richer notifications (and how rich we want them)
    getNotifications(chainAccountId: ID, fractalId: ID): Notifications
}

type FractalEdge {
    node: Fractal
    cursor: String
}
# Global / System-level queries
type fractalList {
    totalCount: Int!
    edges: [FractalEdge]
    pageInfo: PageInfo
}

# Mutations
#--Account
#- Send
#- Swap
#- ClaimFunds
#- CancelTransfer
#--Council
#- voteOnAPetition
#--Veto Council
#- vetoPetition
#--Posts
#- createPost
#- EditPost?
#- Like/DislikePost
#- commentOnPost
#- commentOnComment?
#--Petitions
#- proposePetition (option to mark petition "important", requiring the 21 day review)
#--Recruitment
#- inviteToAccount
#- approveAccount
#- InviteToJoinFractal
#- approveJoinFractal
#--Membership
#- evictMember
#- resignMember
#- clearMember
#--Fractal
#- createFractal
#- founderInviteToFractal
#- founderUpdateFractalProfile
